substitutions:
    esp_name: blind-1
    esp_friendly_name: 'Rolling blind 1'
    hotspot_name: 'Blind 1'
    static_ip_address: 192.168.0.151
    i2c_device_address: '0x30'
    delay_ir_led_on: '1000'
    threshold_voltage: '1.2'

globals:
    - id: motor_speed
      type: int
      restore_value: yes
      initial_value: '10000'
    - id: invert_rotation
      type: bool
      restore_value: yes
      initial_value: 'false'

esphome:
    name: ${esp_name}
    friendly_name: ${esp_friendly_name}

esp32:
    board: esp32dev
    framework:
        type: esp-idf

logger:

api:
    encryption:
        key: 'BNJ3i+lSOra5xn0Ozf5gWXZ0LgYBOmnQSXgGjuy+Bc4='

ota:
    - platform: esphome
      password: 'b87c6d369c4ca417b376c0916778520b'

wifi:
    ssid: !secret wifi_ssid
    password: !secret wifi_password
    fast_connect: True
    manual_ip:
        static_ip: ${static_ip_address}
        gateway: 192.168.0.1
        subnet: 255.255.255.0
    ap:
        ssid: ${hotspot_name}
        password: !secret wifi_password

captive_portal:

i2c:
    sda: GPIO21
    scl: GPIO22
    scan: true

i2c_device:
    id: motor_controller
    address: ${i2c_device_address}

web_server:
    local: true

script:
    - id: move_motor
      parameters:
          channel: int # 0=channel A, 1=channel B
          operation: int # 0=Brake, 1=CCW, 2=CW, 3=Stop, 4=Standby
      then:
          - lambda: |-
                uint8_t final_operation = operation;

                // If inversion is ON, swap 1 (CCW) and 2 (CW)
                if (id(invert_rotation)) {
                  if (operation == 1) final_operation = 2;
                  else if (operation == 2) final_operation = 1;
                }

                uint16_t pwm_val = id(motor_speed); 
                uint8_t data[4] = {
                  (uint8_t)(channel | 0x10), 
                  (uint8_t)final_operation, 
                  (uint8_t)(pwm_val >> 8),
                  (uint8_t)pwm_val
                };
                id(motor_controller).write(data, 4);

    - id: blinds_open_action
      parameters:
          channel: int
      then:
          - lambda: id(move_motor)->execute(channel, 1);

    - id: blinds_close_action
      parameters:
          channel: int
      then:
          - lambda: id(move_motor)->execute(channel, 2);

    - id: blinds_stop_action
      parameters:
          channel: int
      then:
          - lambda: |-
                uint8_t data[4] = {
                  (uint8_t)(channel | 0x10), 
                  1,    // operation
                  0x00, // pwm high
                  0x00  // pwm low
                };
                id(motor_controller).write(data, 4);
number:
    - platform: template
      name: 'Motor speed'
      id: motor_speed_input
      optimistic: true
      min_value: 250
      max_value: 10000
      step: 250
      restore_value: true
      initial_value: 10000
      set_action:
          then:
              - lambda: id(motor_speed) = x;
              - logger.log:
                    format: 'Motor speed changed to: %.1f'
                    args: ['x']

switch:
    - platform: gpio
      id: ir_led_1
      name: 'IR Transmitter LED 1'
      pin: GPIO16
      internal: true

    - platform: template
      name: 'Invert motor direction'
      id: motor_inversion_switch
      optimistic: true
      restore_mode: RESTORE_DEFAULT_OFF
      turn_on_action:
          - lambda: id(invert_rotation) = true;
      turn_off_action:
          - lambda: id(invert_rotation) = false;

sensor:
    - platform: adc
      id: ir_raw_sensor_1
      name: 'IR Receiver Raw Voltage 1'
      pin: GPIO36
      update_interval: 50ms
      unit_of_measurement: 'V'
      accuracy_decimals: 2
      attenuation: auto
      internal: true
      filters:
          - lambda: if (id(ir_led_1).state) return x; else return {};
          - timeout:
                timeout: 500ms
                value: 0

binary_sensor:
    - platform: template
      id: proxy_adc_1
      name: 'Proxy ADC 1'
      internal: true
      lambda: return id(ir_raw_sensor_1).state > ${threshold_voltage};

cover:
    - platform: endstop
      name: 'Blind'
      open_duration: 17.5s
      close_duration: 19s
      max_duration: 21s
      open_endstop: proxy_adc_1
      close_endstop: proxy_adc_1

      open_action:
          - lambda: id(blinds_open_action)->execute(0);
          - delay: !lambda return ${delay_ir_led_on};
          - switch.turn_on: ir_led_1

      close_action:
          - lambda: id(blinds_close_action)->execute(0);
          - delay: !lambda return ${delay_ir_led_on};
          - switch.turn_on: ir_led_1

      stop_action:
          - switch.turn_off: ir_led_1
          - lambda: id(blinds_stop_action)->execute(0);
