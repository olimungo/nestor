substitutions:
    blind_number: 0
    i2c_device_address: 0x30
    delay_led_on: 1000ms
    static_ip_prefix: !secret static_ip_prefix

globals:
    - id: motor_speed
      type: int
      restore_value: yes
      initial_value: '10000'
    - id: threshold_voltage
      type: float
      restore_value: yes
      initial_value: '0.9'
    - id: invert_rotation
      type: bool
      restore_value: yes
      initial_value: 'false'

esphome:
    name: blind-${blind_number}
    friendly_name: 'Rolling blind ${blind_number}'

esp32:
    board: esp32dev
    framework:
        type: esp-idf

wifi:
    ssid: !secret wifi_ssid
    password: !secret wifi_password
    fast_connect: True
    manual_ip:
        static_ip: ${static_ip_prefix}${blind_number}
        gateway: !secret gateway
        subnet: !secret subnet
    ap:
        ssid: 'Blind ${blind_number}'
        password: !secret ap_password

captive_portal:

web_server:
    local: true

ota:
    - platform: esphome
      id: ota_conf
      password: !secret ota_password

api:
    encryption:
        key: !secret api_key

logger:

i2c:
    sda: GPIO21
    scl: GPIO22
    scan: true

i2c_device:
    id: motor_controller
    address: ${i2c_device_address}

script:
    - id: move_motor
      parameters:
          action: int # 0=Brake, 1=CCW, 2=CW, 3=Stop, 4=Standby
      then:
          - lambda: |-
                uint8_t final_action = action;

                // If inversion is ON, swap 1 (CCW) and 2 (CW)
                if (id(invert_rotation)) {
                    if (action == 1) final_action = 2;
                    if (action == 2) final_action = 1;
                }

                uint16_t pwm = id(motor_speed); 

                uint8_t data[4] = {
                    0x00 | 0x10, // channel
                    (uint8_t)final_action, // action
                    (uint8_t)(pwm >> 8), // speed: high byte
                    (uint8_t)pwm // speed: low byte
                };

                id(motor_controller).write(data, 4);

    - id: blinds_open_action
      then:
          - script.execute:
              id: move_motor
              action: 1

    - id: blinds_close_action
      then:
          - script.execute:
              id: move_motor
              action: 2

    - id: blinds_stop_action
      then:
          - script.execute:
              id: move_motor
              action: 0
          - delay: 500ms
          - script.execute:
              id: move_motor
              action: 4
              
number:
    - platform: template
      name: 'Motor speed'
      id: motor_speed_input
      optimistic: true
      min_value: 250
      max_value: 10000
      step: 250
      restore_value: true
      initial_value: 10000
      set_action:
          then:
              - lambda: id(motor_speed) = x;
              - logger.log:
                    format: 'Motor speed changed to: %.1f'
                    args: ['x']

    - platform: template
      name: 'Threshold voltage'
      id: threshold_voltage_input
      optimistic: true
      min_value: 0.5
      max_value: 3.0
      step: 0.1
      restore_value: true
      initial_value: 0.9
      set_action:
          then:
              - lambda: id(threshold_voltage) = x;
              - logger.log:
                    format: 'Threshold voltage changed to: %.1f'
                    args: ['x']

switch:
    - platform: gpio
      id: led_power_switch
      name: 'LED power switch'
      pin: GPIO16
      internal: true

    - platform: template
      name: 'Invert motor direction'
      id: motor_inversion_switch
      optimistic: true
      lambda: return id(invert_rotation);
      turn_on_action:
          - lambda: id(invert_rotation) = true;
      turn_off_action:
          - lambda: id(invert_rotation) = false;

sensor:
    - platform: adc
      id: photoresistor_sensor
      name: 'Photoresistor sensor'
      pin: GPIO36
      update_interval: 50ms
      unit_of_measurement: 'V'
      accuracy_decimals: 2
      attenuation: auto
      internal: true
      filters:
          - lambda: if (id(led_power_switch).state) return x; else return {};
          - timeout:
                timeout: 500ms
                value: 0

binary_sensor:
    - platform: template
      id: photoresistor_binary_sensor
      name: 'Photoresistor binary sensor'
      internal: true
      lambda: return id(photoresistor_sensor).state > id(threshold_voltage);

cover:
    - platform: endstop
      name: 'Blind'
      open_duration: 17.5s
      close_duration: 19s
      max_duration: 21s
      open_endstop: photoresistor_binary_sensor
      close_endstop: photoresistor_binary_sensor

      open_action:
          - script.execute: blinds_open_action
          - delay: ${delay_led_on}
          - switch.turn_on: led_power_switch

      close_action:
          - script.execute: blinds_close_action
          - delay: ${delay_led_on}
          - switch.turn_on: led_power_switch

      stop_action:
          - switch.turn_off: led_power_switch
          - script.execute: blinds_stop_action
